// SPDX-License-Identifier: BUSL-1.1

pragma solidity ^0.8.19;

import {ECDSA} from 'solady/src/utils/ECDSA.sol';

/**
 * @title Framework:Types
 * @notice The base EIP-712 types that power a modern intent framework.
 * @dev This file was auto-generated by @nftchance/emporium-types/cli 
 *      and should not be edited directly otherwise the alchemy 
 *      will fail and you will have to pay with a piece of your soul.
 *      (https://github.com/nftchance/emporium-types)
 * @dev This interface and the consuming abstract are auto-generated by
 *      types declared in the framework configuration at (./config.ts). 
 *      As an extensible base, all projects build on top of Permissions 
 *      and Intents.
 * @author @nftchance
 * @author @nftchance/emporium-types (2023-11-03)
 * @author @danfinlay (https://github.com/delegatable/delegatable-sol)
 * @author @KamesGeraghty (https://github.com/kamescg)
 */
interface ITypes {
	/**
     * @notice This struct is used to encode EIP712Domain data into a hash and
     *         decode EIP712Domain data from a hash.
     * 
     * @dev EIP712Domain extends EIP712<{ 
     *    { name: 'name', type: 'string' }
	 *    { name: 'version', type: 'string' }
	 *    { name: 'chainId', type: 'uint256' }
	 *    { name: 'verifyingContract', type: 'address' }
     * }>
     */
    struct EIP712Domain {
		string name;
		string version;
		uint256 chainId;
		address verifyingContract;
	}

	/**
     * @notice This struct is used to encode Caveat data into a hash and
     *         decode Caveat data from a hash.
     * 
     * @dev Caveat extends EIP712<{ 
     *    { name: 'enforcer', type: 'address' }
	 *    { name: 'terms', type: 'bytes' }
     * }>
     */
    struct Caveat {
		address enforcer;
		bytes terms;
	}

	/**
     * @notice This struct is used to encode Permission data into a hash and
     *         decode Permission data from a hash.
     * 
     * @dev Permission extends EIP712<{ 
     *    { name: 'delegate', type: 'address' }
	 *    { name: 'authority', type: 'bytes32' }
	 *    { name: 'caveats', type: 'Caveat[]' }
	 *    { name: 'salt', type: 'bytes32' }
     * }>
     */
    struct Permission {
		address delegate;
		bytes32 authority;
		Caveat[] caveats;
		bytes32 salt;
	}

	/**
     * @notice This struct is used to encode Transaction data into a hash and
     *         decode Transaction data from a hash.
     * 
     * @dev Transaction extends EIP712<{ 
     *    { name: 'to', type: 'address' }
	 *    { name: 'gasLimit', type: 'uint256' }
	 *    { name: 'data', type: 'bytes' }
     * }>
     */
    struct Transaction {
		address to;
		uint256 gasLimit;
		bytes data;
	}

	/**
     * @notice This struct is used to encode SignedPermission data into a hash and
     *         decode SignedPermission data from a hash.
     * 
     * @dev SignedPermission extends EIP712<{ 
     *    { name: 'permission', type: 'Permission' }
	 *    { name: 'signature', type: 'bytes' }
     * }>
     */
    struct SignedPermission {
		Permission permission;
		bytes signature;
	}

	/**
     * @notice This struct is used to encode Intent data into a hash and
     *         decode Intent data from a hash.
     * 
     * @dev Intent extends EIP712<{ 
     *    { name: 'transaction', type: 'Transaction' }
	 *    { name: 'authority', type: 'SignedPermission[]' }
     * }>
     */
    struct Intent {
		Transaction transaction;
		SignedPermission[] authority;
	}

	/**
     * @notice This struct is used to encode ReplayProtection data into a hash and
     *         decode ReplayProtection data from a hash.
     * 
     * @dev ReplayProtection extends EIP712<{ 
     *    { name: 'nonce', type: 'uint256' }
	 *    { name: 'queue', type: 'uint256' }
     * }>
     */
    struct ReplayProtection {
		uint256 nonce;
		uint256 queue;
	}

	/**
     * @notice This struct is used to encode Intents data into a hash and
     *         decode Intents data from a hash.
     * 
     * @dev Intents extends EIP712<{ 
     *    { name: 'batch', type: 'Intent[]' }
	 *    { name: 'replayProtection', type: 'ReplayProtection' }
     * }>
     */
    struct Intents {
		Intent[] batch;
		ReplayProtection replayProtection;
	}

	/**
     * @notice This struct is used to encode SignedIntents data into a hash and
     *         decode SignedIntents data from a hash.
     * 
     * @dev SignedIntents extends EIP712<{ 
     *    { name: 'intents', type: 'Intents' }
	 *    { name: 'signature', type: 'bytes' }
     * }>
     */
    struct SignedIntents {
		Intents intents;
		bytes signature;
	}
}

/**
 * @title Framework:Types 
 * @dev This file was auto-generated by @nftchance/emporium-types/cli.
 *      (https://github.com/nftchance/emporium-types)
 * @dev This abstract contract is auto-generated and should not be edited directly
 *      however it should be directly inherited from in the consuming protocol
 *      to power the processing of generalized intents.
 * @author @nftchance
 * @author @nftchance/emporium-types (2023-11-03)
 * @author @danfinlay (https://github.com/delegatable/delegatable-sol)
 * @author @KamesGeraghty (https://github.com/kamescg)
 */
abstract contract Types is ITypes {
    /// @notice Use the ECDSA library for signature verification.
    using ECDSA for bytes32;

    /// @notice The hash of the domain separator used in the EIP712 domain hash.
    bytes32 public immutable domainHash;

	/**
     * @notice Type hash representing the EIP712Domain data type providing EIP-712
     *      compatability for encoding and decoding.
     * @dev EIP712_DOMAIN_TYPEHASH extends TypeHash<EIP712<{
     *       { name: 'name', type: 'string' }
	 * .     { name: 'version', type: 'string' }
	 * .     { name: 'chainId', type: 'uint256' }
	 * .     { name: 'verifyingContract', type: 'address' } 
     *      }>>
        */
    bytes32 constant EIP712_DOMAIN_TYPEHASH = keccak256(
        'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'
    );

	/**
     * @notice Type hash representing the Caveat data type providing EIP-712
     *      compatability for encoding and decoding.
     * @dev CAVEAT_TYPEHASH extends TypeHash<EIP712<{
     *       { name: 'enforcer', type: 'address' }
	 * .     { name: 'terms', type: 'bytes' } 
     *      }>>
        */
    bytes32 constant CAVEAT_TYPEHASH = keccak256(
        'Caveat(address enforcer,bytes terms)'
    );

	/**
     * @notice Type hash representing the Permission data type providing EIP-712
     *      compatability for encoding and decoding.
     * @dev PERMISSION_TYPEHASH extends TypeHash<EIP712<{
     *       { name: 'delegate', type: 'address' }
	 * .     { name: 'authority', type: 'bytes32' }
	 * .     { name: 'caveats', type: 'Caveat[]' }
	 * .     { name: 'salt', type: 'bytes32' } 
     *      }>>
        */
    bytes32 constant PERMISSION_TYPEHASH = keccak256(
        'Permission(address delegate,bytes32 authority,Caveat[] caveats,bytes32 salt)Caveat(address enforcer,bytes terms)'
    );

	/**
     * @notice Type hash representing the Transaction data type providing EIP-712
     *      compatability for encoding and decoding.
     * @dev TRANSACTION_TYPEHASH extends TypeHash<EIP712<{
     *       { name: 'to', type: 'address' }
	 * .     { name: 'gasLimit', type: 'uint256' }
	 * .     { name: 'data', type: 'bytes' } 
     *      }>>
        */
    bytes32 constant TRANSACTION_TYPEHASH = keccak256(
        'Transaction(address to,uint256 gasLimit,bytes data)'
    );

	/**
     * @notice Type hash representing the SignedPermission data type providing EIP-712
     *      compatability for encoding and decoding.
     * @dev SIGNED_PERMISSION_TYPEHASH extends TypeHash<EIP712<{
     *       { name: 'permission', type: 'Permission' }
	 * .     { name: 'signature', type: 'bytes' } 
     *      }>>
        */
    bytes32 constant SIGNED_PERMISSION_TYPEHASH = keccak256(
        'SignedPermission(Permission permission,bytes signature)Caveat(address enforcer,bytes terms)Permission(address delegate,bytes32 authority,Caveat[] caveats,bytes32 salt)'
    );

	/**
     * @notice Type hash representing the Intent data type providing EIP-712
     *      compatability for encoding and decoding.
     * @dev INTENT_TYPEHASH extends TypeHash<EIP712<{
     *       { name: 'transaction', type: 'Transaction' }
	 * .     { name: 'authority', type: 'SignedPermission[]' } 
     *      }>>
        */
    bytes32 constant INTENT_TYPEHASH = keccak256(
        'Intent(Transaction transaction,SignedPermission[] authority)Caveat(address enforcer,bytes terms)Permission(address delegate,bytes32 authority,Caveat[] caveats,bytes32 salt)SignedPermission(Permission permission,bytes signature)Transaction(address to,uint256 gasLimit,bytes data)'
    );

	/**
     * @notice Type hash representing the ReplayProtection data type providing EIP-712
     *      compatability for encoding and decoding.
     * @dev REPLAY_PROTECTION_TYPEHASH extends TypeHash<EIP712<{
     *       { name: 'nonce', type: 'uint256' }
	 * .     { name: 'queue', type: 'uint256' } 
     *      }>>
        */
    bytes32 constant REPLAY_PROTECTION_TYPEHASH = keccak256(
        'ReplayProtection(uint256 nonce,uint256 queue)'
    );

	/**
     * @notice Type hash representing the Intents data type providing EIP-712
     *      compatability for encoding and decoding.
     * @dev INTENTS_TYPEHASH extends TypeHash<EIP712<{
     *       { name: 'batch', type: 'Intent[]' }
	 * .     { name: 'replayProtection', type: 'ReplayProtection' } 
     *      }>>
        */
    bytes32 constant INTENTS_TYPEHASH = keccak256(
        'Intents(Intent[] batch,ReplayProtection replayProtection)Caveat(address enforcer,bytes terms)Intent(Transaction transaction,SignedPermission[] authority)Permission(address delegate,bytes32 authority,Caveat[] caveats,bytes32 salt)ReplayProtection(uint256 nonce,uint256 queue)SignedPermission(Permission permission,bytes signature)Transaction(address to,uint256 gasLimit,bytes data)'
    );

	/**
     * @notice Type hash representing the SignedIntents data type providing EIP-712
     *      compatability for encoding and decoding.
     * @dev SIGNED_INTENTS_TYPEHASH extends TypeHash<EIP712<{
     *       { name: 'intents', type: 'Intents' }
	 * .     { name: 'signature', type: 'bytes' } 
     *      }>>
        */
    bytes32 constant SIGNED_INTENTS_TYPEHASH = keccak256(
        'SignedIntents(Intents intents,bytes signature)Caveat(address enforcer,bytes terms)Intent(Transaction transaction,SignedPermission[] authority)Intents(Intent[] batch,ReplayProtection replayProtection)Permission(address delegate,bytes32 authority,Caveat[] caveats,bytes32 salt)ReplayProtection(uint256 nonce,uint256 queue)SignedPermission(Permission permission,bytes signature)Transaction(address to,uint256 gasLimit,bytes data)'
    );
	/**
     * @notice Instantiate the contract with the name and version of the protocol.
     * @param $name The name of the protocol.
     * @param $version The version of the protocol.
     * @dev The chainId is pulled from the block and the verifying contract is set to the
     *      address of the contract.
     */
    constructor(string memory $name, string memory $version) {
        /// @dev Sets the domain hash for the contract.
        domainHash = getEIP712DomainHash(EIP712Domain({
            name: $name,
            version: $version,
            chainId: block.chainid,
            verifyingContract: address(this)
        }));
    }

	/**
     * @notice Encode EIP712Domain data into a packet hash and verify decoded EIP712Domain data 
     *         from a packet hash to verify type compliance.
     * @param $input The EIP712Domain data to encode.
     * @return $hash The packet hash of the encoded EIP712Domain data.
     */
    function getEIP712DomainHash(
        EIP712Domain memory $input
    ) public pure virtual returns (bytes32 $hash) {
        $hash = keccak256(abi.encode(
            EIP712_DOMAIN_TYPEHASH,
            keccak256(bytes($input.name)),
			keccak256(bytes($input.version)),
			$input.chainId,
			$input.verifyingContract
        ));
    }

	/**
     * @notice Encode Caveat data into a packet hash and verify decoded Caveat data 
     *         from a packet hash to verify type compliance.
     * @param $input The Caveat data to encode.
     * @return $hash The packet hash of the encoded Caveat data.
     */
    function getCaveatHash(
        Caveat memory $input
    ) public pure virtual returns (bytes32 $hash) {
        $hash = keccak256(abi.encode(
            CAVEAT_TYPEHASH,
            $input.enforcer,
			keccak256($input.terms)
        ));
    }

	/**
     * @notice Encode Permission data into a packet hash and verify decoded Permission data 
     *         from a packet hash to verify type compliance.
     * @param $input The Permission data to encode.
     * @return $hash The packet hash of the encoded Permission data.
     */
    function getPermissionHash(
        Permission memory $input
    ) public pure virtual returns (bytes32 $hash) {
        $hash = keccak256(abi.encode(
            PERMISSION_TYPEHASH,
            $input.delegate,
			$input.authority,
			getCaveatArrayHash($input.caveats),
			$input.salt
        ));
    }

	/*** @notice Encode Caveat[] data into hash and verify the 
     *         decoded Caveat[] data from a packet hash to verify type compliance.
     * @param $input The Caveat[] data to encode. 
     * @return $hash The packet hash of the encoded Caveat[] data.
     */
    function getCaveatArrayHash(
        Caveat[] memory $input
    )  public pure virtual returns (bytes32 $hash) {
        /// @dev Load the stack.
        bytes memory encoded;
        uint256 i;
        uint256 length = $input.length;

        /// @dev Encode each item in the array.
        for (i; i < length;) {
            encoded = bytes.concat(
                encoded,
                getCaveatHash($input[i])
            );

            unchecked { i++; }
        }
        
        /// @dev Hash the encoded array.
        $hash = keccak256(encoded);
    }

	/**
     * @notice Encode Transaction data into a packet hash and verify decoded Transaction data 
     *         from a packet hash to verify type compliance.
     * @param $input The Transaction data to encode.
     * @return $hash The packet hash of the encoded Transaction data.
     */
    function getTransactionHash(
        Transaction memory $input
    ) public pure virtual returns (bytes32 $hash) {
        $hash = keccak256(abi.encode(
            TRANSACTION_TYPEHASH,
            $input.to,
			$input.gasLimit,
			keccak256($input.data)
        ));
    }

	/**
     * @notice Encode SignedPermission data into a packet hash and verify decoded SignedPermission data 
     *         from a packet hash to verify type compliance.
     * @param $input The SignedPermission data to encode.
     * @return $hash The packet hash of the encoded SignedPermission data.
     */
    function getSignedPermissionHash(
        SignedPermission memory $input
    ) public pure virtual returns (bytes32 $hash) {
        $hash = keccak256(abi.encode(
            SIGNED_PERMISSION_TYPEHASH,
            getPermissionHash($input.permission),
			keccak256($input.signature)
        ));
    }

	/**
     * @notice Encode Intent data into a packet hash and verify decoded Intent data 
     *         from a packet hash to verify type compliance.
     * @param $input The Intent data to encode.
     * @return $hash The packet hash of the encoded Intent data.
     */
    function getIntentHash(
        Intent memory $input
    ) public pure virtual returns (bytes32 $hash) {
        $hash = keccak256(abi.encode(
            INTENT_TYPEHASH,
            getTransactionHash($input.transaction),
			getSignedPermissionArrayHash($input.authority)
        ));
    }

	/*** @notice Encode SignedPermission[] data into hash and verify the 
     *         decoded SignedPermission[] data from a packet hash to verify type compliance.
     * @param $input The SignedPermission[] data to encode. 
     * @return $hash The packet hash of the encoded SignedPermission[] data.
     */
    function getSignedPermissionArrayHash(
        SignedPermission[] memory $input
    )  public pure virtual returns (bytes32 $hash) {
        /// @dev Load the stack.
        bytes memory encoded;
        uint256 i;
        uint256 length = $input.length;

        /// @dev Encode each item in the array.
        for (i; i < length;) {
            encoded = bytes.concat(
                encoded,
                getSignedPermissionHash($input[i])
            );

            unchecked { i++; }
        }
        
        /// @dev Hash the encoded array.
        $hash = keccak256(encoded);
    }

	/**
     * @notice Encode ReplayProtection data into a packet hash and verify decoded ReplayProtection data 
     *         from a packet hash to verify type compliance.
     * @param $input The ReplayProtection data to encode.
     * @return $hash The packet hash of the encoded ReplayProtection data.
     */
    function getReplayProtectionHash(
        ReplayProtection memory $input
    ) public pure virtual returns (bytes32 $hash) {
        $hash = keccak256(abi.encode(
            REPLAY_PROTECTION_TYPEHASH,
            $input.nonce,
			$input.queue
        ));
    }

	/**
     * @notice Encode Intents data into a packet hash and verify decoded Intents data 
     *         from a packet hash to verify type compliance.
     * @param $input The Intents data to encode.
     * @return $hash The packet hash of the encoded Intents data.
     */
    function getIntentsHash(
        Intents memory $input
    ) public pure virtual returns (bytes32 $hash) {
        $hash = keccak256(abi.encode(
            INTENTS_TYPEHASH,
            getIntentArrayHash($input.batch),
			getReplayProtectionHash($input.replayProtection)
        ));
    }

	/*** @notice Encode Intent[] data into hash and verify the 
     *         decoded Intent[] data from a packet hash to verify type compliance.
     * @param $input The Intent[] data to encode. 
     * @return $hash The packet hash of the encoded Intent[] data.
     */
    function getIntentArrayHash(
        Intent[] memory $input
    )  public pure virtual returns (bytes32 $hash) {
        /// @dev Load the stack.
        bytes memory encoded;
        uint256 i;
        uint256 length = $input.length;

        /// @dev Encode each item in the array.
        for (i; i < length;) {
            encoded = bytes.concat(
                encoded,
                getIntentHash($input[i])
            );

            unchecked { i++; }
        }
        
        /// @dev Hash the encoded array.
        $hash = keccak256(encoded);
    }

	/**
     * @notice Encode SignedIntents data into a packet hash and verify decoded SignedIntents data 
     *         from a packet hash to verify type compliance.
     * @param $input The SignedIntents data to encode.
     * @return $hash The packet hash of the encoded SignedIntents data.
     */
    function getSignedIntentsHash(
        SignedIntents memory $input
    ) public pure virtual returns (bytes32 $hash) {
        $hash = keccak256(abi.encode(
            SIGNED_INTENTS_TYPEHASH,
            getIntentsHash($input.intents),
			keccak256($input.signature)
        ));
    }
	/**
     * @notice Encode Permission data into a digest hash that has been 
     *         localized to the domain of the contract.
     * @param $input The Permission data to encode.
     * @return $digest The digest hash of the encoded Permission data.
     */
    function getPermissionDigest(
        Permission memory $input
    ) public view virtual returns (bytes32 $digest) {
        $digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                domainHash,
                getPermissionHash($input)
            )
        );
    }

	/**
     * @notice Encode Intents data into a digest hash that has been 
     *         localized to the domain of the contract.
     * @param $input The Intents data to encode.
     * @return $digest The digest hash of the encoded Intents data.
     */
    function getIntentsDigest(
        Intents memory $input
    ) public view virtual returns (bytes32 $digest) {
        $digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                domainHash,
                getIntentsHash($input)
            )
        );
    }
	/**
     * @notice Get the signer of a SignedPermission data type.
     * @param $input The SignedPermission data to encode.
     * @return $signer The signer of the SignedPermission data.
    */
    function getSignedPermissionSigner(
        SignedPermission memory $input
    ) public view virtual returns (address $signer) {
        $signer = getPermissionDigest($input.permission).recover(
            $input.signature
        );
    }

	/**
     * @notice Get the signer of a SignedIntents data type.
     * @param $input The SignedIntents data to encode.
     * @return $signer The signer of the SignedIntents data.
    */
    function getSignedIntentsSigner(
        SignedIntents memory $input
    ) public view virtual returns (address $signer) {
        $signer = getIntentsDigest($input.intents).recover(
            $input.signature
        );
    }
}