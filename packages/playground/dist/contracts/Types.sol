// SPDX-License-Identifier: BUSL-1.1

pragma solidity ^0.8.19;

/**
 * @title Framework:Types
 * @notice The base EIP-712 types that power a modern intent framework.
 * @dev This file was auto-generated by @nftchance/emporium-types/cli 
 *      and should not be edited directly otherwise the alchemy 
 *      will fail and you will have to pay with a piece of your soul.
 *      (https://github.com/nftchance/emporium-types)
 * @dev This interface and the consuming abstract are auto-generated by
 *      types declared in the framework configuration at (./config.ts). 
 *      As an extensible base, all projects build on top of Delegations 
 *      and Invocations.
 * @author @nftchance
 * @author emporium-types@1.0.0 (2023-10-21)
 * @author @danfinlay (https://github.com/delegatable/delegatable-sol)
 */
interface ITypes {
	/**
     * @notice This struct is used to encode Delegation data into a packet hash and
     *         decode Delegation data from a packet hash.
     * 
     * Delegation extends EIP712<{ 
     *    { name: 'delegate', type: 'address' }
	 *    { name: 'authority', type: 'bytes32' }
	 *    { name: 'caveats', type: 'Caveat[]' }
     * }>
     */
    struct Delegation {
		address delegate;
		bytes32 authority;
		Caveat[] caveats;
	}

	/**
     * @notice This struct is used to encode Caveat data into a packet hash and
     *         decode Caveat data from a packet hash.
     * 
     * Caveat extends EIP712<{ 
     *    { name: 'enforcer', type: 'address' }
	 *    { name: 'terms', type: 'bytes' }
     * }>
     */
    struct Caveat {
		address enforcer;
		bytes terms;
	}

	/**
     * @notice This struct is used to encode Transaction data into a packet hash and
     *         decode Transaction data from a packet hash.
     * 
     * Transaction extends EIP712<{ 
     *    { name: 'to', type: 'address' }
	 *    { name: 'gasLimit', type: 'uint256' }
	 *    { name: 'data', type: 'bytes' }
     * }>
     */
    struct Transaction {
		address to;
		uint256 gasLimit;
		bytes data;
	}

	/**
     * @notice This struct is used to encode SignedDelegation data into a packet hash and
     *         decode SignedDelegation data from a packet hash.
     * 
     * SignedDelegation extends EIP712<{ 
     *    { name: 'delegation', type: 'Delegation' }
	 *    { name: 'signature', type: 'bytes' }
	 *    { name: 'signerIsContract', type: 'bool' }
     * }>
     */
    struct SignedDelegation {
		Delegation delegation;
		bytes signature;
		bool signerIsContract;
	}

	/**
     * @notice This struct is used to encode Invocation data into a packet hash and
     *         decode Invocation data from a packet hash.
     * 
     * Invocation extends EIP712<{ 
     *    { name: 'transaction', type: 'Transaction' }
	 *    { name: 'authority', type: 'SignedDelegation[]' }
     * }>
     */
    struct Invocation {
		Transaction transaction;
		SignedDelegation[] authority;
	}

	/**
     * @notice This struct is used to encode ReplayProtection data into a packet hash and
     *         decode ReplayProtection data from a packet hash.
     * 
     * ReplayProtection extends EIP712<{ 
     *    { name: 'nonce', type: 'uint256' }
	 *    { name: 'queue', type: 'uint256' }
     * }>
     */
    struct ReplayProtection {
		uint256 nonce;
		uint256 queue;
	}

	/**
     * @notice This struct is used to encode Invocations data into a packet hash and
     *         decode Invocations data from a packet hash.
     * 
     * Invocations extends EIP712<{ 
     *    { name: 'batch', type: 'Invocation[]' }
	 *    { name: 'replayProtection', type: 'ReplayProtection' }
     * }>
     */
    struct Invocations {
		Invocation[] batch;
		ReplayProtection replayProtection;
	}
}

/**
 * @title Framework:Types 
 * @dev This file was auto-generated by @nftchance/emporium-types/cli.
 *      (https://github.com/nftchance/emporium-types)
 * @dev This abstract contract is auto-generated and should not be edited directly
 *      however it should be directly inherited from in the consuming protocol
 *      to power the processing of generalized intents.
 * @author @nftchance
 * @author emporium-types@1.0.0 (2023-10-21)
 * @author @danfinlay (https://github.com/delegatable/delegatable-sol)
 */
abstract contract Types is ITypes {
	/**
     * @dev Type hash representing the Delegation data type providing EIP-712
     *      compatability for encoding and decoding.
     * 
     * DELEGATION_TYPEHASH extends TypeHash<EIP712<{
     *   { name: 'delegate', type: 'address' }
	 *   { name: 'authority', type: 'bytes32' }
	 *   { name: 'caveats', type: 'Caveat[]' } 
     * }>>
     */
    bytes32 constant DELEGATION_TYPEHASH = keccak256('Delegation(address delegate,bytes32 authority,Caveat[] caveats)Caveat(address enforcer,bytes terms)');

	/**
     * @dev Type hash representing the Caveat data type providing EIP-712
     *      compatability for encoding and decoding.
     * 
     * CAVEAT_TYPEHASH extends TypeHash<EIP712<{
     *   { name: 'enforcer', type: 'address' }
	 *   { name: 'terms', type: 'bytes' } 
     * }>>
     */
    bytes32 constant CAVEAT_TYPEHASH = keccak256('Caveat(address enforcer,bytes terms)');

	/**
     * @dev Type hash representing the Transaction data type providing EIP-712
     *      compatability for encoding and decoding.
     * 
     * TRANSACTION_TYPEHASH extends TypeHash<EIP712<{
     *   { name: 'to', type: 'address' }
	 *   { name: 'gasLimit', type: 'uint256' }
	 *   { name: 'data', type: 'bytes' } 
     * }>>
     */
    bytes32 constant TRANSACTION_TYPEHASH = keccak256('Transaction(address to,uint256 gasLimit,bytes data)');

	/**
     * @dev Type hash representing the SignedDelegation data type providing EIP-712
     *      compatability for encoding and decoding.
     * 
     * SIGNED_DELEGATION_TYPEHASH extends TypeHash<EIP712<{
     *   { name: 'delegation', type: 'Delegation' }
	 *   { name: 'signature', type: 'bytes' }
	 *   { name: 'signerIsContract', type: 'bool' } 
     * }>>
     */
    bytes32 constant SIGNED_DELEGATION_TYPEHASH = keccak256('SignedDelegation(Delegation delegation,bytes signature,bool signerIsContract)Caveat(address enforcer,bytes terms)Delegation(address delegate,bytes32 authority,Caveat[] caveats)');

	/**
     * @dev Type hash representing the Invocation data type providing EIP-712
     *      compatability for encoding and decoding.
     * 
     * INVOCATION_TYPEHASH extends TypeHash<EIP712<{
     *   { name: 'transaction', type: 'Transaction' }
	 *   { name: 'authority', type: 'SignedDelegation[]' } 
     * }>>
     */
    bytes32 constant INVOCATION_TYPEHASH = keccak256('Invocation(Transaction transaction,SignedDelegation[] authority)Caveat(address enforcer,bytes terms)Delegation(address delegate,bytes32 authority,Caveat[] caveats)SignedDelegation(Delegation delegation,bytes signature,bool signerIsContract)Transaction(address to,uint256 gasLimit,bytes data)');

	/**
     * @dev Type hash representing the ReplayProtection data type providing EIP-712
     *      compatability for encoding and decoding.
     * 
     * REPLAY_PROTECTION_TYPEHASH extends TypeHash<EIP712<{
     *   { name: 'nonce', type: 'uint256' }
	 *   { name: 'queue', type: 'uint256' } 
     * }>>
     */
    bytes32 constant REPLAY_PROTECTION_TYPEHASH = keccak256('ReplayProtection(uint256 nonce,uint256 queue)');

	/**
     * @dev Type hash representing the Invocations data type providing EIP-712
     *      compatability for encoding and decoding.
     * 
     * INVOCATIONS_TYPEHASH extends TypeHash<EIP712<{
     *   { name: 'batch', type: 'Invocation[]' }
	 *   { name: 'replayProtection', type: 'ReplayProtection' } 
     * }>>
     */
    bytes32 constant INVOCATIONS_TYPEHASH = keccak256('Invocations(Invocation[] batch,ReplayProtection replayProtection)Caveat(address enforcer,bytes terms)Delegation(address delegate,bytes32 authority,Caveat[] caveats)Invocation(Transaction transaction,SignedDelegation[] authority)ReplayProtection(uint256 nonce,uint256 queue)SignedDelegation(Delegation delegation,bytes signature,bool signerIsContract)Transaction(address to,uint256 gasLimit,bytes data)');

	/**
     * @notice Encode Delegation data into a packet hash and verify decoded Delegation data 
     *         from a packet hash to verify type compliance and value-width alignment.
     * @param $input The Delegation data to encode.
     * @return $hash The packet hash of the encoded Delegation data.
     */
    function getPacketHash(
        Delegation memory $input
    )
        public
        pure
        returns (bytes32 $hash)
    {
        $hash = keccak256(abi.encode(
            DELEGATION_TYPEHASH,
            $input.delegate,
			$input.authority,
			getArrayPacketHash($input.caveats)
        ));
    }

	/**
     * @notice Encode Caveat[] data into a packet hash and verify decoded Caveat[] data 
     *         from a packet hash to verify type compliance and value-width alignment.
     * @param $input The Caveat[] data to encode. 
     * @return $hash The packet hash of the encoded Caveat[] data.
     */
    function getArrayPacketHash(
        Caveat[] memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        bytes memory encoded;

        uint256 i;
        uint256 length = $input.length;

        for (i; i < length;) {
            encoded = bytes.concat(
                encoded,
                getPacketHash($input[i])
            );

            unchecked { i++; }
        }
        
        $hash = keccak256(encoded);
    }
	/**
     * @notice Encode Caveat data into a packet hash and verify decoded Caveat data 
     *         from a packet hash to verify type compliance and value-width alignment.
     * @param $input The Caveat data to encode.
     * @return $hash The packet hash of the encoded Caveat data.
     */
    function getPacketHash(
        Caveat memory $input
    )
        public
        pure
        returns (bytes32 $hash)
    {
        $hash = keccak256(abi.encode(
            CAVEAT_TYPEHASH,
            $input.enforcer,
			keccak256($input.terms)
        ));
    }

	/**
     * @notice Encode Transaction data into a packet hash and verify decoded Transaction data 
     *         from a packet hash to verify type compliance and value-width alignment.
     * @param $input The Transaction data to encode.
     * @return $hash The packet hash of the encoded Transaction data.
     */
    function getPacketHash(
        Transaction memory $input
    )
        public
        pure
        returns (bytes32 $hash)
    {
        $hash = keccak256(abi.encode(
            TRANSACTION_TYPEHASH,
            $input.to,
			$input.gasLimit,
			keccak256($input.data)
        ));
    }

	/**
     * @notice Encode SignedDelegation data into a packet hash and verify decoded SignedDelegation data 
     *         from a packet hash to verify type compliance and value-width alignment.
     * @param $input The SignedDelegation data to encode.
     * @return $hash The packet hash of the encoded SignedDelegation data.
     */
    function getPacketHash(
        SignedDelegation memory $input
    )
        public
        pure
        returns (bytes32 $hash)
    {
        $hash = keccak256(abi.encode(
            SIGNED_DELEGATION_TYPEHASH,
            getPacketHash($input.delegation),
			keccak256($input.signature),
			$input.signerIsContract
        ));
    }

	/**
     * @notice Encode Invocation data into a packet hash and verify decoded Invocation data 
     *         from a packet hash to verify type compliance and value-width alignment.
     * @param $input The Invocation data to encode.
     * @return $hash The packet hash of the encoded Invocation data.
     */
    function getPacketHash(
        Invocation memory $input
    )
        public
        pure
        returns (bytes32 $hash)
    {
        $hash = keccak256(abi.encode(
            INVOCATION_TYPEHASH,
            getPacketHash($input.transaction),
			getArrayPacketHash($input.authority)
        ));
    }

	/**
     * @notice Encode SignedDelegation[] data into a packet hash and verify decoded SignedDelegation[] data 
     *         from a packet hash to verify type compliance and value-width alignment.
     * @param $input The SignedDelegation[] data to encode. 
     * @return $hash The packet hash of the encoded SignedDelegation[] data.
     */
    function getArrayPacketHash(
        SignedDelegation[] memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        bytes memory encoded;

        uint256 i;
        uint256 length = $input.length;

        for (i; i < length;) {
            encoded = bytes.concat(
                encoded,
                getPacketHash($input[i])
            );

            unchecked { i++; }
        }
        
        $hash = keccak256(encoded);
    }
	/**
     * @notice Encode ReplayProtection data into a packet hash and verify decoded ReplayProtection data 
     *         from a packet hash to verify type compliance and value-width alignment.
     * @param $input The ReplayProtection data to encode.
     * @return $hash The packet hash of the encoded ReplayProtection data.
     */
    function getPacketHash(
        ReplayProtection memory $input
    )
        public
        pure
        returns (bytes32 $hash)
    {
        $hash = keccak256(abi.encode(
            REPLAY_PROTECTION_TYPEHASH,
            $input.nonce,
			$input.queue
        ));
    }

	/**
     * @notice Encode Invocations data into a packet hash and verify decoded Invocations data 
     *         from a packet hash to verify type compliance and value-width alignment.
     * @param $input The Invocations data to encode.
     * @return $hash The packet hash of the encoded Invocations data.
     */
    function getPacketHash(
        Invocations memory $input
    )
        public
        pure
        returns (bytes32 $hash)
    {
        $hash = keccak256(abi.encode(
            INVOCATIONS_TYPEHASH,
            getArrayPacketHash($input.batch),
			getPacketHash($input.replayProtection)
        ));
    }

	/**
     * @notice Encode Invocation[] data into a packet hash and verify decoded Invocation[] data 
     *         from a packet hash to verify type compliance and value-width alignment.
     * @param $input The Invocation[] data to encode. 
     * @return $hash The packet hash of the encoded Invocation[] data.
     */
    function getArrayPacketHash(
        Invocation[] memory $input
    ) 
        public 
        pure 
        returns (bytes32 $hash) 
    {
        bytes memory encoded;

        uint256 i;
        uint256 length = $input.length;

        for (i; i < length;) {
            encoded = bytes.concat(
                encoded,
                getPacketHash($input[i])
            );

            unchecked { i++; }
        }
        
        $hash = keccak256(encoded);
    }
}