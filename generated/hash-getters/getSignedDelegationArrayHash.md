---
head:
  - - meta
    - property: og:title
      content: getSignedDelegationArrayHash
  - - meta
    - name: description
      content: Encode an array of SignedDelegations into a hash and verify the decoded data to verify type compliance.
  - - meta
    - property: og:description
      content: Encode an array of SignedDelegations into a hash and verify the decoded data to verify type compliance.
notes:
  - - author: Auto generated by @nftchance/plug-types/cli
---

# getSignedDelegationArrayHash

Encode an array of [SignedDelegations](/generated/base-types/SignedDelegation) into a hash and verify the decoded [SignedDelegation](/generated/base-types/SignedDelegation) data from a hash to verify type compliance.

## Parameters

- `$input` : [SignedDelegation[]](/generated/base-types/SignedDelegation) : The `SignedDelegation[]` data to encode.

## Returns

- `$hash` : `bytes32` : The hash of the encoded [SignedDelegation](/generated/base-types/SignedDelegation) array data.

## Onchain Implementation

With `getSignedDelegationArrayHash` you can call the function as a `read` and get the built hash back.

This is helpful in times when you need to build a message hash without tracking down all the types as well as when you need to verify a signed message hash containing a `SignedDelegation[]` data type.

::: code-group

```solidity [Types.sol:getSignedDelegationArrayHash]
function getSignedDelegationArrayHash(
	SignedDelegation[] memory $input
)  public pure virtual returns (bytes32 $hash) {
	/// @dev Load the stack.
	bytes memory encoded;
	uint256 i;
	uint256 length = $input.length;

	/// @dev Encode each item in the array.
	for (i; i < length;) {
		encoded = bytes.concat(
			encoded,
			getSignedDelegationHash($input[i])
		);

		unchecked { i++; }
	}

	/// @dev Hash the encoded array.
	$hash = keccak256(encoded);
}
```

:::
