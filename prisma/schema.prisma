generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["fullTextSearch", "fullTextIndex"]
}

generator dbml { 
    provider = "prisma-dbml-generator"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    address String  @id @default(cuid())
    name    String?

    nextVaultSalt    String?
    nextVaultAddress String?

    workflows Workflow[]
    vaults    UserVault[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Workflow {
    id   String @id @default(uuid())
    name String @default("Untitled Workflow")

    // The unsigned version of the components in a workflow.
    actions Action[]

    workflowForkedId String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Backwards relational fields.
    user        User?   @relation(fields: [userAddress], references: [address])
    userAddress String?
}

// Onchain models.
model Vault {
    address String
    chainId Int
    name    String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Backwards relational fields.
    UserVault UserVault[]

    @@id([address, chainId])
}

model UserVault {
    user        User   @relation(fields: [userAddress], references: [address])
    userAddress String

    vault        Vault  @relation(fields: [vaultAddress, vaultChainId], references: [address, chainId])
    vaultAddress String
    vaultChainId Int

    // Store live plugs relative to a user vault because if the address that owns the
    // vault changes, then the signatures are no longer valid. However, if they reacquire
    // ownership then the signatures should be automatically available again.
    livePlugs LivePlugs[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    Plugs     Plugs[]

    @@id([userAddress, vaultAddress, vaultChainId])
}

model Action {
    id String @id @default(uuid())

    // The index that denotes the place in the order in case the array is ever unordered.
    index Int

    // Onchain fields.
    target String
    value  String
    data   String

    // Backwards relational fields.
    Workflow   Workflow? @relation(fields: [workflowId], references: [id])
    workflowId String?
    plugs      Plugs?    @relation(fields: [plugsId], references: [id])
    plugsId    String?
}

model Plugs {
    id String @id @default(uuid())

    // Signature & simulation related fields.
    chainId    Int[]
    executions Execution[]

    // Onchain fields.
    socket  UserVault @relation(fields: [vaultUserAddress, vaultAddress, vaultChainId], references: [userAddress, vaultAddress, vaultChainId])
    actions Action[]
    salt    String
    fee     Int

    // Backwards relational fields.
    vaultUserAddress String
    vaultAddress     String
    vaultChainId     Int
    livePlugs        LivePlugs[]
}

model LivePlugs {
    id String @id @default(uuid())

    // Onchain fields.
    plugs     Plugs  @relation(fields: [plugsId], references: [id])
    plugsId   String
    signature String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Backwards relational fields.
    vault            UserVault @relation(fields: [vaultUserAddress, vaultAddress, vaultChainId], references: [userAddress, vaultAddress, vaultChainId])
    vaultUserAddress String
    vaultAddress     String
    vaultChainId     Int
}

model Execution {
    id String @id @default(uuid())

    simulation Boolean

    // TODO: Store the results of a simulation.

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    Plugs   Plugs?  @relation(fields: [plugsId], references: [id])
    plugsId String?
}
